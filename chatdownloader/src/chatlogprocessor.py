"""
Processes chat logs using the metrics and exports them via the
leaderboard.
"""

import logging

from metrics import EXPORTED_METRICS
from _types import ChatLog
from dataclasses import dataclass


@dataclass
class UserChatPerformance:
    id: str
    username: str
    avatar: str
    metrics: dict[str, int]


class ChatLogProcessor:
    """
    Processes the chat logs.

    The class uses the metrics package to extract metrics from the
    chat messages, the metadata package to extract any user-metadata,
    and the leaderboards package to export the metrics / required user
    metadata to the right people
    """
    def _parse_to_log_object(self, chat_log_path: str) -> ChatLog:
        with open(chat_log_path, "r", encoding="utf8") as f:
            chat_logs = ChatLog.from_json(f.read())

        return chat_logs

    def parse(self, chat_log_path: str) -> list[UserChatPerformance]:
        """
        Given a chat log generated by the Twitch Downloader CLI tool,
        parses the messages and produces a list connecting a user to metrics

        :param chat_log_path: The path to the chat log file
        :return: A list of {UserChatPerformance} objects
        """
        logging.info("Parsing chat logs...")
        chatlog = self._parse_to_log_object(chat_log_path)
        pre_performance = {}

        # initialize all the metric classes
        metric_instances = [m() for m in EXPORTED_METRICS]

        for seq_no, comment in enumerate(chatlog.comments):
            logging.debug("Processing comment by %s", comment.commenter.display_name)
            if comment.commenter._id not in pre_performance:
                pre_performance[comment.commenter._id] = UserChatPerformance(
                id=comment.commenter._id,
                username=comment.commenter.display_name,
                avatar=comment.commenter.logo,
                metrics={m.get_name(): 0 for m in metric_instances})

            metric_update_arr = {
                metric.get_name(): metric.get_metric(comment, seq_no)
                for metric in metric_instances}

            for k, v in metric_update_arr.items():
                for user_id, met_value in v.items():
                    # NOTE: the user_id will definitely exist
                    pre_performance[user_id].metrics[k] += met_value

        return pre_performance.values()

if __name__ == '__main__':
    clp = ChatLogProcessor()
    print(clp.parse('src/result.json'))
